<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="favicon.jpeg">
  <title>Nostarium demo</title>
  <style>
    :root {
      --panel-w: 340px;
      --panel-gap: 10px;
      --panel-pad: 12px;
      --safe-left: calc(var(--panel-w) + var(--panel-pad) + 12px);
    }

    html, body {
      margin: 0;
      height: 100%;
      background: #06131a;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: #cfe8f3;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* Left fixed UI stack (must not overlap fish area by design) */
    .ui {
      position: absolute;
      left: var(--panel-pad);
      top: var(--panel-pad);
      width: var(--panel-w);
      display: flex;
      flex-direction: column;
      gap: var(--panel-gap);
      pointer-events: none;
      z-index: 10;
    }

    .panel {
      pointer-events: auto;
      border-radius: 14px;
      background: rgba(7, 22, 30, 0.72);
      border: 1px solid rgba(160, 210, 230, 0.18);
      box-shadow: 0 12px 35px rgba(0,0,0,0.35);
      padding: 10px 12px;
      backdrop-filter: blur(8px);
    }

    .title {
      font-weight: 700;
      font-size: 14px;
      letter-spacing: 0.2px;
      margin: 0 0 8px 0;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }

    .small {
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.4;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }

    label {
      font-size: 12px;
      opacity: 0.9;
      min-width: 48px;
    }

    input {
      flex: 1;
      min-width: 0;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(160, 210, 230, 0.22);
      background: rgba(5, 16, 22, 0.55);
      color: #cfe8f3;
      outline: none;
    }

    select {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(160, 210, 230, 0.22);
      background: rgba(5, 16, 22, 0.55);
      color: #cfe8f3;
      outline: none;
      min-width: 92px;
    }

    button {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(160, 210, 230, 0.22);
      background: rgba(20, 70, 90, 0.35);
      color: #cfe8f3;
      cursor: pointer;
      font-weight: 600;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .hint {
      font-size: 12px;
      opacity: 0.85;
      margin-top: 8px;
    }

    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      white-space: pre-wrap;
      word-break: break-word;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(160, 210, 230, 0.14);
      border-radius: 10px;
      padding: 8px;
      max-height: 170px;
      overflow: auto;
    }

    .feed {
      font-size: 12px;
      max-height: 380px;
      overflow: auto;
      border-radius: 10px;
      border: 1px solid rgba(160, 210, 230, 0.14);
      background: rgba(0,0,0,0.18);
    }

    .feedItem {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(160, 210, 230, 0.10);
    }
    .feedItem:last-child { border-bottom: 0; }

    .feedTop {
      display: flex;
      gap: 8px;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
    }

    .feedName { font-weight: 700; }
    .feedTime { opacity: 0.8; font-size: 11px; }

    @media (max-width: 900px) {
      .ui { width: calc(100vw - 24px); }
      .postsPanel { display: none; }
    }
  </style>
</head>
<body>
  <canvas id="tank"></canvas>

  <div class="ui">
    <div class="panel">
      <div class="title">
        <span>Relay</span>
        <span class="small" id="version"></span>
      </div>

      <div class="row">
        <label for="relay">Relay</label>
        <input id="relay" type="text" value="wss://yabu.me" spellcheck="false" />
      </div>

      <div class="row">
        <label for="range">Range</label>
        <select id="range">
          <option value="600" selected>10分</option>
          <option value="1200">20分</option>
          <option value="1800">30分</option>
          <option value="3600">1時間</option>
        </select>
        <button id="btnConnect">Connect</button>
        <button id="btnDisconnect" disabled>Disconnect</button>
      </div>

      <div class="small" id="status"></div>
      <div class="small" id="activeCount"></div>

      <div class="hint">Nostarium mock — 魚 = 選択レンジ内に投稿したユーザ（Nostrリレー購読 / 読み取り専用）</div>
      <div class="log" id="log"></div>
    </div>

    <div class="panel postsPanel">
      <div class="title">
        <span>Posts</span>
        <span class="small" id="postStats"></span>
      </div>
      <div class="feed" id="feed"></div>
    </div>
  </div>

  <script>
    // ---- Version ----
    const APP_VERSION = '0.3.7';

    // ---- DOM ----
    const canvas = document.getElementById('tank');
    const ctx = canvas.getContext('2d');

    const relayInput = document.getElementById('relay');
    const rangeSelect = document.getElementById('range');
    const btnConnect = document.getElementById('btnConnect');
    const btnDisconnect = document.getElementById('btnDisconnect');

    const statusEl = document.getElementById('status');
    const versionEl = document.getElementById('version');
    const activeCountEl = document.getElementById('activeCount');
    const logEl = document.getElementById('log');

    const feedEl = document.getElementById('feed');
    const postStatsEl = document.getElementById('postStats');

    // ---- Helpers ----
    function nowMs() { return Date.now(); }

    function safeLeftPx() {
      // Keep in sync with CSS variable semantics.
      const w = 340;
      const pad = 12;
      const extra = 12;
      return w + pad + extra;
    }

    function normalizePubkey(pubkey) {
      return String(pubkey == null ? '' : pubkey).trim().toLowerCase();
    }

    function shortKey(pubkey) {
      const p = normalizePubkey(pubkey);
      if (!p) return 'unknown';
      return p.slice(0, 8);
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function timeLabel(sec) {
      // ローカルタイム（JST）で表示
      try {
        const d = new Date(sec * 1000);
        return d.toLocaleString('ja-JP', {
          timeZone: 'Asia/Tokyo',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
      } catch {
        return '';
      }
    }

    function timeLabelShort(sec) {
      try {
        const d = new Date(sec * 1000);
        // 例: 01/18 13:45
        return d.toLocaleString('ja-JP', {
          timeZone: 'Asia/Tokyo',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
      } catch {
        return '';
      }
    }

    // ---- Logging / status ----
    const LOG_MAX_CHARS = 12000;
    function log(line) {
      const s = String(line);
      const prev = logEl.textContent || '';
      const next = (prev ? (prev + '\n') : '') + s;
      logEl.textContent = next.length > LOG_MAX_CHARS ? next.slice(next.length - LOG_MAX_CHARS) : next;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    // ---- Range ----
    let ACTIVE_WINDOW_SEC = 3600;
    function readRangeSec() {
      const v = Number(rangeSelect && rangeSelect.value);
      return (Number.isFinite(v) && v > 0) ? v : 3600;
    }

    function updateActiveCountIfNeeded() {
      if (!fishCountDirty) return;
      fishCountDirty = false;
      const mins = Math.round(ACTIVE_WINDOW_SEC / 60);
      const text = 'active (last ' + mins + 'm): ' + fishes.length;
      if (text !== lastActiveCountText) {
        activeCountEl.textContent = text;
        lastActiveCountText = text;
      }
    }

    // Back-compat: existing callers keep using this.
    function updateActiveCount() {
      markFishCountDirty();
      updateActiveCountIfNeeded();
    }

    // ---- Data ----
    /** @type {Map<string, any>} */
    const fishByPubkey = new Map();
    /** @type {any[]} */
    const fishes = [];
    /** @type {any[]} */
    const bubbles = [];

    /** @type {any[]} */
    const posts = [];
    const postIds = new Set();

    const profileCache = new Map();

    // avatar image cache (pubkey -> { url, img, state })
    const avatarCache = new Map();

    // ---- Performance knobs ----
    const TARGET_FPS = 30;
    const FRAME_MS = 1000 / TARGET_FPS;
    let isPaused = false;
    let lastFrameTs = 0;

    // Active count UI update: dirty (avoid DOM updates every frame)
    let fishCountDirty = true;
    let lastActiveCountText = '';
    function markFishCountDirty() { fishCountDirty = true; }
    const requestedProfiles = new Set();
    const pendingProfiles = new Set();
    let profileInFlight = false;
    let profileTimer = null;
    let subIdProfiles = null;

    // ---- WebSocket ----
    let ws = null;
    let subIdPosts = null;
    const activeSubs = new Set();
    let reqSent = 0;
    let eventsRecv = 0;
    let lastRecvMs = 0;

    function randId(prefix) {
      return prefix + '-' + Math.random().toString(16).slice(2) + '-' + Date.now().toString(16);
    }

    function send(payload) {
      if (!ws || ws.readyState !== 1) return;
      const s = JSON.stringify(payload);
      log('SEND ' + s);
      ws.send(s);
    }

    function sendReq(subId, filter) {
      send(['REQ', subId, filter]);
      reqSent++;
      activeSubs.add(subId);
      updateStatusLine();
    }

    function sendClose(subId) {
      if (!subId) return;
      send(['CLOSE', subId]);
      activeSubs.delete(subId);
      updateStatusLine();
    }

    function updateStatusLine() {
      const rs = ws ? ws.readyState : -1;
      const since = lastRecvMs ? ((nowMs() - lastRecvMs) / 1000).toFixed(1) + 's' : '-';
      setStatus(
        'ws=' + rs +
        ' subs=' + activeSubs.size +
        ' reqSent=' + reqSent +
        ' events=' + eventsRecv +
        ' lastRecv=' + since
      );
    }

    function disconnectRelay() {
      try {
        if (profileTimer) {
          clearTimeout(profileTimer);
          profileTimer = null;
        }
        profileInFlight = false;

        if (ws && ws.readyState === 1) {
          sendClose(subIdPosts);
          sendClose(subIdProfiles);
        }

        if (ws) {
          ws.onopen = null;
          ws.onmessage = null;
          ws.onerror = null;
          ws.onclose = null;
          try { ws.close(); } catch {}
        }
      } finally {
        ws = null;
        subIdPosts = null;
        subIdProfiles = null;
        activeSubs.clear();
        updateStatusLine();
        btnConnect.disabled = false;
        btnDisconnect.disabled = true;
        log('WS closed');
      }
    }

    function connectRelay(url) {
      disconnectRelay();

      ACTIVE_WINDOW_SEC = readRangeSec();
      updateActiveCount();

      setStatus('connecting: ' + url);
      log('CONNECT ' + url);

      ws = new WebSocket(url);
      btnConnect.disabled = true;
      btnDisconnect.disabled = false;

      ws.onopen = () => {
        log('WS opened');
        updateStatusLine();

        // Reset profile queue state per connection
        pendingProfiles.clear();
        requestedProfiles.clear();
        profileInFlight = false;
        subIdProfiles = null;
        if (profileTimer) {
          clearTimeout(profileTimer);
          profileTimer = null;
        }

        // Subscribe posts (kind 1) within window
        subIdPosts = randId('posts');
        const now = Math.floor(Date.now() / 1000);
        const since = now - ACTIVE_WINDOW_SEC;
        const filter = { kinds: [1], since: since, limit: 200 };
        sendReq(subIdPosts, filter);
      };

      ws.onmessage = (ev) => {
        lastRecvMs = nowMs();
        let msg;
        try {
          msg = JSON.parse(ev.data);
        } catch {
          log('RECV (non-json) ' + String(ev.data).slice(0, 200));
          return;
        }

        const typ = msg && msg[0];
        if (!typ) return;

        if (typ === 'EVENT') {
          eventsRecv++;
          updateStatusLine();
          const subId = msg[1];
          const e = msg[2];
          if (!e || typeof e.kind !== 'number') return;

          if (e.kind === 1) handleNoteEvent(e);
          else if (e.kind === 0) handleProfileEvent(e);
          // ignore other kinds
        } else if (typ === 'EOSE') {
          const subId = msg[1];
          log('EOSE ' + String(subId || ''));
          // End of stored events for profiles sub; used to close profile batches.
          if (subId && subId === subIdProfiles) {
            finishProfileBatch();
          }
        } else if (typ === 'NOTICE') {
          log('NOTICE ' + String(msg[1] || ''));
        } else if (typ === 'OK') {
          // read-only client, can ignore
        }
      };

      ws.onerror = () => {
        log('WS error');
        updateStatusLine();
      };

      ws.onclose = (ev) => {
        log('WS closed code=' + ev.code + ' reason=' + (ev.reason || ''));
        updateStatusLine();
        btnConnect.disabled = false;
        btnDisconnect.disabled = true;
      };
    }

    // ---- Posts ----
    function addPost(e) {
      if (!e || !e.id) return;
      if (postIds.has(e.id)) return;
      postIds.add(e.id);

      posts.unshift({
        id: e.id,
        pubkey: normalizePubkey(e.pubkey),
        createdAtSec: e.created_at || 0,
        content: String(e.content || '')
      });

      // cap
      if (posts.length > 200) {
        const removed = posts.splice(200);
        for (const r of removed) postIds.delete(r.id);
      }

      renderPosts();
    }

    function renderPosts() {
      const items = posts.slice(0, 80);
      feedEl.innerHTML = items.map(p => {
        const prof = profileCache.get(p.pubkey);
        const name = (prof && prof.name) ? ('@' + prof.name) : ('@' + shortKey(p.pubkey));
        const text = p.content.replace(/\s+/g, ' ').slice(0, 120);
        const t = timeLabelShort(p.createdAtSec);
        return (
          '<div class="feedItem">' +
          '  <div class="feedTop">' +
          '    <span class="feedName">' + escapeHtml(name) + '</span>' +
          '    <span class="feedTime">' + escapeHtml(t) + '</span>' +
          '  </div>' +
          '  <div class="small">' + escapeHtml(text) + '</div>' +
          '</div>'
        );
      }).join('');

      postStatsEl.textContent = 'showing ' + items.length + ' / total ' + posts.length;
      // 常に最新（先頭）が見えるようにする
      feedEl.scrollTop = 0;
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // ---- Fish ----
    function ensureFish(pubkey) {
      const pk = normalizePubkey(pubkey);
      if (!pk) return null;
      let f = fishByPubkey.get(pk);
      if (f) return f;

      const SAFE_LEFT = safeLeftPx();
      const w = Math.max(64, canvas.width - SAFE_LEFT);

      f = {
        pubkey: pk,
        name: '@' + shortKey(pk),
        avatarUrl: '',
        latestText: '',
        latestCreatedAtSec: 0,
        lastSeenMs: 0,
        x: SAFE_LEFT + Math.random() * w,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.7,
        vy: (Math.random() - 0.5) * 0.45,
        size: 10 + Math.random() * 12,
        activity: 0.18 + Math.random() * 0.22,
        hue: Math.random() * 360,
        bubbleCooldown: 10 + Math.random() * 120
      };

      fishes.push(f);
      fishByPubkey.set(pk, f);

      enqueueProfile(pk);
      markFishCountDirty();
      updateActiveCountIfNeeded();
      return f;
    }

    function handleNoteEvent(e) {
      addPost(e);

      const f = ensureFish(e.pubkey);
      if (!f) return;

      // update fish state
      const now = nowMs();
      const createdAtSecRaw = e.created_at;
      const createdAtSec = Number(createdAtSecRaw || 0);
      const MAX_FUTURE_SKEW_SEC = 300; // 5 min

      // lastSeenMs は原則「投稿時刻(created_at)」を基準にする。
      // ただし created_at 欠損/異常/未来すぎる値は寿命判定を壊すので安全側にクランプしてログする。
      let postAtMs = 0;
      if (!Number.isFinite(createdAtSec) || createdAtSec <= 0) {
        postAtMs = now;
        log('WARN created_at missing/invalid for ' + shortKey(e.pubkey) + ' raw=' + String(createdAtSecRaw));
      } else {
        const ms = createdAtSec * 1000;
        const maxFutureMs = now + MAX_FUTURE_SKEW_SEC * 1000;
        if (ms > maxFutureMs) {
          postAtMs = now;
          log('WARN created_at too-future for ' + shortKey(e.pubkey) + ' created_at=' + createdAtSec + ' (clamped)');
        } else {
          postAtMs = ms;
        }
      }

      f.lastSeenMs = Math.max(f.lastSeenMs || 0, postAtMs);
      f.activity = Math.min(1, f.activity + 0.15);

      // 最新投稿の更新は created_at が新しい場合のみ（created_at欠損時は postAtMs を秒に丸めて比較する）
      const effectiveCreatedAtSec = (Number.isFinite(createdAtSec) && createdAtSec > 0)
        ? createdAtSec
        : Math.floor(postAtMs / 1000);

      if (effectiveCreatedAtSec >= (f.latestCreatedAtSec || 0)) {
        f.latestCreatedAtSec = effectiveCreatedAtSec;
        f.latestText = String(e.content || '').replace(/\s+/g, ' ').slice(0, 240);
      }

      // apply cached profile name if available
      const prof = profileCache.get(f.pubkey);
      if (prof && prof.name) f.name = '@' + prof.name;
      if (prof && prof.picture && !f.avatarUrl) f.avatarUrl = prof.picture;

      updateActiveCountIfNeeded();
    }

    function handleProfileEvent(e) {
      const pk = normalizePubkey(e.pubkey);
      let name = '';
      let picture = '';
      try {
        const obj = JSON.parse(String(e.content || '{}'));
        name = String(obj.display_name || obj.name || '').trim();
        picture = String(obj.picture || obj.image || '').trim();
      } catch {
        name = '';
        picture = '';
      }

      if (name) {
        const prev = profileCache.get(pk) || {};
        profileCache.set(pk, { name, picture: picture || prev.picture || '' });
        log('PROFILE ' + pk.slice(0, 8) + ' -> @' + name);

        const f = fishByPubkey.get(pk);
        if (f) f.name = '@' + name;
      } else if (picture) {
        // name が無くても picture は拾う
        const prev = profileCache.get(pk) || {};
        profileCache.set(pk, { name: prev.name || '', picture });
      }

      if (picture) {
        const f = fishByPubkey.get(pk);
        if (f) f.avatarUrl = picture;
      }

      renderPosts();
    }

    // ---- Profile batching (kind 0) ----
    const PROFILE_BATCH_MAX = 60;
    const PROFILE_BATCH_TIMEOUT_MS = 2500;

    function enqueueProfile(pubkey) {
      const pk = normalizePubkey(pubkey);
      if (!pk) return;

      const cached = profileCache.get(pk);
      if (cached && cached.name) return;

      if (requestedProfiles.has(pk)) return;
      requestedProfiles.add(pk);
      pendingProfiles.add(pk);

      scheduleProfileFetch();
    }

    function scheduleProfileFetch() {
      if (!ws || ws.readyState !== 1) return;
      if (profileInFlight) return;
      if (pendingProfiles.size === 0) return;

      profileInFlight = true;

      const authors = [];
      for (const pk of pendingProfiles) {
        authors.push(pk);
        if (authors.length >= PROFILE_BATCH_MAX) break;
      }
      for (const pk of authors) pendingProfiles.delete(pk);

      subIdProfiles = randId('profiles');
      const filter = { kinds: [0], authors: authors, limit: authors.length };
      sendReq(subIdProfiles, filter);

      // Safety close if relay never sends EOSE.
      if (profileTimer) clearTimeout(profileTimer);
      profileTimer = setTimeout(() => {
        log('profiles timeout -> CLOSE');
        finishProfileBatch();
      }, PROFILE_BATCH_TIMEOUT_MS);
    }

    function finishProfileBatch() {
      if (profileTimer) {
        clearTimeout(profileTimer);
        profileTimer = null;
      }
      if (subIdProfiles) {
        sendClose(subIdProfiles);
        subIdProfiles = null;
      }
      profileInFlight = false;

      // If still pending, schedule next batch.
      if (pendingProfiles.size > 0) {
        // Small delay to avoid hammering.
        setTimeout(scheduleProfileFetch, 120);
      }
    }

    // ---- Animation / drawing ----
    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Keep fishes in bounds
      const SAFE_LEFT = safeLeftPx();
      for (const f of fishes) {
        f.x = clamp(f.x, SAFE_LEFT, window.innerWidth);
        f.y = clamp(f.y, 0, window.innerHeight);
      }
    }

    function removeExpiredFishes(now) {
      // lastSeenMs は投稿時刻ベース。now との差分で Range 外の魚を消す。
      for (let i = fishes.length - 1; i >= 0; i--) {
        const f = fishes[i];
        const last = Number(f.lastSeenMs || 0);
        if (last > 0 && (now - last > ACTIVE_WINDOW_SEC * 1000)) {
          fishByPubkey.delete(f.pubkey);
          fishes.splice(i, 1);
          markFishCountDirty();
          updateActiveCountIfNeeded();
          log('PRUNE ' + f.pubkey.slice(0, 8) + ' ageSec=' + ((now - last) / 1000).toFixed(1));
        }
      }
    }

    function update() {
      const now = nowMs();
      removeExpiredFishes(now);

      const SAFE_LEFT = safeLeftPx();
      const w = window.innerWidth;
      const h = window.innerHeight;

      for (const f of fishes) {
        f.x += f.vx;
        f.y += f.vy;

        if (f.x < SAFE_LEFT || f.x > w) f.vx *= -1;
        if (f.y < 0 || f.y > h) f.vy *= -1;

        f.x = clamp(f.x, SAFE_LEFT, w);
        f.y = clamp(f.y, 0, h);

        f.activity = Math.max(0, f.activity - 0.0008);

        f.bubbleCooldown--;
        if (f.bubbleCooldown <= 0) {
          bubbles.push({ x: f.x, y: f.y - f.size, r: 2 + Math.random() * 2, life: 120 });
          const base = 70 + Math.random() * 140;
          const boost = (1 - f.activity) * 80;
          f.bubbleCooldown = base + boost;
        }
      }

      for (const b of bubbles) {
        b.y -= 0.3;
        b.life--;
      }
      for (let i = bubbles.length - 1; i >= 0; i--) {
        if (bubbles[i].life <= 0) bubbles.splice(i, 1);
      }

      // No per-frame DOM updates.
      updateActiveCountIfNeeded();
    }

    function drawBackground() {
      const w = window.innerWidth;
      const h = window.innerHeight;

      // gradient water
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, 'rgba(10, 40, 55, 1)');
      g.addColorStop(1, 'rgba(2, 10, 16, 1)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      // faint light rays
      ctx.globalAlpha = 0.10;
      for (let i = 0; i < 8; i++) {
        const x = (w * (i + 0.5)) / 8;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x + 80, h);
        ctx.lineTo(x - 20, h);
        ctx.closePath();
        ctx.fillStyle = 'rgba(200, 240, 255, 0.35)';
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // safe-left visual separator (debug-friendly but subtle)
      const SAFE_LEFT = safeLeftPx();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = 'rgba(220, 250, 255, 1)';
      ctx.fillRect(SAFE_LEFT, 0, 1, h);
      ctx.globalAlpha = 1;
    }

    function roundRectPath(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function wrapLinesByWidth(ctx, text, maxWidth, maxLines) {
      const s = String(text || '').replace(/\s+/g, ' ').trim();
      if (!s) return [];

      // 日本語（スペースが少ない）も想定して、基本は1文字ずつのラップ。
      const chars = Array.from(s);
      const lines = [];
      let line = '';

      for (let i = 0; i < chars.length; i++) {
        const ch = chars[i];
        const test = line + ch;
        if (ctx.measureText(test).width <= maxWidth || line.length === 0) {
          line = test;
        } else {
          lines.push(line);
          line = ch;
          if (lines.length >= maxLines - 1) break;
        }
      }
      if (line && lines.length < maxLines) lines.push(line);

      // 省略（三点リーダ）: 必ず maxWidth に収める
      if (lines.length === maxLines && chars.length > 0) {
        let last = lines[maxLines - 1];
        while (last && ctx.measureText(last + '…').width > maxWidth) {
          last = last.slice(0, -1);
        }
        lines[maxLines - 1] = (last || '').trimEnd() + '…';
      }

      return lines;
    }

    function ensureAvatarLoaded(pubkey, url) {
      const pk = normalizePubkey(pubkey);
      const u = String(url || '').trim();
      if (!pk || !u) return;

      const cur = avatarCache.get(pk);
      if (cur && cur.url === u && (cur.state === 'loaded' || cur.state === 'loading')) return;

      const img = new Image();
      // NOTE: crossOrigin を強制すると、CORSヘッダ無しの画像が読み込めずアイコンが出ないことがある。
      // ここでは敢えて設定しない（canvasがtaintされても本アプリはピクセル読み取りをしないため問題ない）。
      avatarCache.set(pk, { url: u, img, state: 'loading' });

      img.onload = () => {
        const rec = avatarCache.get(pk);
        if (rec && rec.img === img) rec.state = 'loaded';
      };
      img.onerror = () => {
        const rec = avatarCache.get(pk);
        if (rec && rec.img === img) rec.state = 'error';
      };
      img.src = u;
    }

    function drawAvatarCircle(f, cx, cy, r) {
      const prof = profileCache.get(f.pubkey);
      const url = (f.avatarUrl || (prof && prof.picture) || '').trim();
      if (url) ensureAvatarLoaded(f.pubkey, url);

      const rec = avatarCache.get(f.pubkey);
      if (rec && rec.state === 'loaded' && rec.img && rec.img.naturalWidth > 0) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();

        // cover-crop
        const iw = rec.img.naturalWidth;
        const ih = rec.img.naturalHeight;
        const s = Math.max((r * 2) / iw, (r * 2) / ih);
        const dw = iw * s;
        const dh = ih * s;
        const dx = cx - dw / 2;
        const dy = cy - dh / 2;
        ctx.drawImage(rec.img, dx, dy, dw, dh);

        ctx.restore();

        // border
        ctx.save();
        ctx.strokeStyle = 'rgba(200, 240, 255, 0.35)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        return;
      }

      // fallback: colored dot
      ctx.save();
      ctx.fillStyle = 'hsla(' + f.hue + ', 70%, 60%, 0.95)';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function ellipsizeToWidth(ctx, text, maxWidth) {
      const s = String(text || '');
      if (ctx.measureText(s).width <= maxWidth) return s;
      let t = s;
      while (t.length > 0 && ctx.measureText(t + '…').width > maxWidth) {
        t = t.slice(0, -1);
      }
      return (t || '').trimEnd() + '…';
    }

    function computeBubbleLayout(f) {
      const name = f.name || ('@' + shortKey(f.pubkey));
      const timeStr = f.latestCreatedAtSec ? timeLabelShort(f.latestCreatedAtSec) : '';
      const headerTextRaw = name + (timeStr ? ('  ' + timeStr) : '');
      const bodyRaw = String(f.latestText || '');
      const key = headerTextRaw + '¥n' + bodyRaw;

      if (f._bubbleLayout && f._bubbleLayout.key === key) return f._bubbleLayout;

      const pad = 8;
      const gap = 6;
      const maxW = 280;
      const headerFont = '12px ui-sans-serif, system-ui';
      const bodyFont = '11px ui-sans-serif, system-ui';
      const lineH = 14;
      const iconR = 8;
      const iconSpace = iconR * 2 + 6;

      ctx.save();

      // First pass: wrap at max inner width
      const maxInner = maxW - pad * 2;
      ctx.font = bodyFont;
      let lines = wrapLinesByWidth(ctx, bodyRaw, maxInner, 3);
      let bodyW = 0;
      for (const ln of lines) bodyW = Math.max(bodyW, ctx.measureText(ln).width);

      // Header measurement
      ctx.font = headerFont;
      const headerTextW = ctx.measureText(headerTextRaw).width;
      const headerW = iconSpace + headerTextW;

      // Decide bubble width
      const bubbleW = Math.min(maxW, Math.max(190, Math.max(headerW, bodyW) + pad * 2));
      const innerW = bubbleW - pad * 2;

      // Second pass: re-wrap to actual inner width
      ctx.font = bodyFont;
      lines = wrapLinesByWidth(ctx, bodyRaw, innerW, 3);
      for (let i = 0; i < lines.length; i++) {
        if (ctx.measureText(lines[i]).width > innerW) {
          lines[i] = ellipsizeToWidth(ctx, lines[i], innerW);
        }
      }

      // Header ellipsize to fit
      ctx.font = headerFont;
      const maxHeaderTextW = Math.max(0, innerW - iconSpace);
      const headerText = ellipsizeToWidth(ctx, headerTextRaw, maxHeaderTextW);

      const bodyH = lines.length ? (lines.length * lineH) : 0;
      const headerH = 18;
      const bubbleH = pad * 2 + headerH + (lines.length ? (gap + bodyH) : 0);

      ctx.restore();

      f._bubbleLayout = {
        key,
        pad,
        gap,
        bubbleW,
        bubbleH,
        innerW,
        headerFont,
        bodyFont,
        headerH,
        lineH,
        iconR,
        iconSpace,
        headerText,
        lines
      };
      return f._bubbleLayout;
    }

    function drawSpeechBubble(f) {
      const SAFE_LEFT = safeLeftPx();
      const layout = computeBubbleLayout(f);

      const pad = layout.pad;
      const gap = layout.gap;
      const bubbleW = layout.bubbleW;
      const bubbleH = layout.bubbleH;
      const innerW = layout.innerW;

      // position above fish, clamped within screen and outside UI safe area
      let bx = f.x - bubbleW / 2;
      let by = f.y - f.size * 2.6 - bubbleH;
      bx = clamp(bx, SAFE_LEFT + 6, window.innerWidth - bubbleW - 6);
      by = clamp(by, 6, window.innerHeight - bubbleH - 6);

      ctx.save();

      // bubble
      ctx.fillStyle = 'rgba(6, 18, 26, 0.80)';
      ctx.strokeStyle = 'rgba(200, 240, 255, 0.22)';
      ctx.lineWidth = 1;
      roundRectPath(ctx, bx, by, bubbleW, bubbleH, 12);
      ctx.fill();
      ctx.stroke();

      // tail
      ctx.beginPath();
      ctx.moveTo(f.x, by + bubbleH);
      ctx.lineTo(f.x - 10, by + bubbleH + 10);
      ctx.lineTo(f.x + 10, by + bubbleH + 10);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // header: avatar + text
      const hx = bx + pad;
      const hy = by + pad + 12;

      drawAvatarCircle(f, hx + layout.iconR, hy - 4, layout.iconR);

      ctx.font = layout.headerFont;
      ctx.fillStyle = 'rgba(230, 248, 255, 0.96)';
      ctx.fillText(layout.headerText, hx + layout.iconSpace, hy);

      // body
      if (layout.lines.length) {
        ctx.font = layout.bodyFont;
        ctx.fillStyle = 'rgba(210, 238, 250, 0.90)';
        let ty = by + pad + layout.headerH + gap + 11;
        const tx = bx + pad;
        for (const ln of layout.lines) {
          ctx.fillText(ln, tx, ty);
          ty += layout.lineH;
        }
      }

      ctx.restore();
    }

    function drawFish(f) {
      const w = window.innerWidth;
      const h = window.innerHeight;

      // fish body
      const bodyLen = f.size * 2.4;
      const bodyH = f.size * 1.4;
      const dir = f.vx >= 0 ? 1 : -1;

      ctx.save();
      ctx.translate(f.x, f.y);
      ctx.scale(dir, 1);

      ctx.fillStyle = 'hsla(' + f.hue + ', 70%, 55%, 0.95)';
      ctx.beginPath();
      ctx.ellipse(0, 0, bodyLen * 0.5, bodyH * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // tail
      ctx.fillStyle = 'hsla(' + f.hue + ', 70%, 45%, 0.95)';
      ctx.beginPath();
      ctx.moveTo(-bodyLen * 0.5, 0);
      ctx.lineTo(-bodyLen * 0.8, bodyH * 0.35);
      ctx.lineTo(-bodyLen * 0.8, -bodyH * 0.35);
      ctx.closePath();
      ctx.fill();

      // eye
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.arc(bodyLen * 0.18, -bodyH * 0.12, Math.max(1.5, f.size * 0.12), 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath();
      ctx.arc(bodyLen * 0.2, -bodyH * 0.12, Math.max(1.0, f.size * 0.07), 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // speech bubble (not mirrored)
      drawSpeechBubble(f);
    }

    function drawBubbles() {
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(200, 240, 255, 0.8)';
      for (const b of bubbles) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function draw() {
      drawBackground();
      drawBubbles();
      for (const f of fishes) drawFish(f);
    }

    function loop(ts) {
      if (isPaused) {
        requestAnimationFrame(loop);
        return;
      }
      if (!lastFrameTs) lastFrameTs = ts;
      const dt = ts - lastFrameTs;
      if (dt < FRAME_MS) {
        requestAnimationFrame(loop);
        return;
      }
      lastFrameTs = ts;

      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ---- Click -> nostter ----
    canvas.addEventListener('click', (ev) => {
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;

      if (x < safeLeftPx()) return; // ignore UI area

      for (let i = fishes.length - 1; i >= 0; i--) {
        const f = fishes[i];
        const dx = x - f.x;
        const dy = y - f.y;
        const r = f.size * 1.9;
        if (dx * dx + dy * dy <= r * r) {
          const npub = toNpub(f.pubkey);
          if (!npub) {
            log('npub convert failed: ' + f.pubkey);
            return;
          }
          const url = 'https://nostter.app/' + npub;
          log('OPEN ' + url);
          window.open(url, '_blank', 'noopener');
          return;
        }
      }
    });

    // ---- Minimal NIP-19 npub encoder (single definition) ----
    const BECH32_ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

    function hexToBytes(hex) {
      const h = String(hex || '').trim();
      if (h.length % 2 !== 0) return null;
      const out = new Uint8Array(h.length / 2);
      for (let i = 0; i < out.length; i++) {
        const v = parseInt(h.slice(i * 2, i * 2 + 2), 16);
        if (!Number.isFinite(v)) return null;
        out[i] = v;
      }
      return out;
    }

    function convertBits(data, from, to, pad) {
      let acc = 0;
      let bits = 0;
      const ret = [];
      const maxv = (1 << to) - 1;
      for (let i = 0; i < data.length; i++) {
        const value = data[i];
        if (value < 0 || (value >> from) !== 0) return null;
        acc = (acc << from) | value;
        bits += from;
        while (bits >= to) {
          bits -= to;
          ret.push((acc >> bits) & maxv);
        }
      }
      if (pad) {
        if (bits > 0) ret.push((acc << (to - bits)) & maxv);
      } else {
        if (bits >= from) return null;
        if (((acc << (to - bits)) & maxv) !== 0) return null;
      }
      return ret;
    }

    function bech32Polymod(values) {
      const GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
      let chk = 1;
      for (let p = 0; p < values.length; p++) {
        const top = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (let i = 0; i < 5; i++) {
          if ((top >> i) & 1) chk ^= GEN[i];
        }
      }
      return chk;
    }

    function bech32HrpExpand(hrp) {
      const ret = [];
      for (let i = 0; i < hrp.length; i++) ret.push(hrp.charCodeAt(i) >> 5);
      ret.push(0);
      for (let i = 0; i < hrp.length; i++) ret.push(hrp.charCodeAt(i) & 31);
      return ret;
    }

    function bech32CreateChecksum(hrp, data) {
      const values = bech32HrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
      const mod = bech32Polymod(values) ^ 1;
      const ret = [];
      for (let p = 0; p < 6; p++) ret.push((mod >> (5 * (5 - p))) & 31);
      return ret;
    }

    function bech32Encode(hrp, data) {
      const combined = data.concat(bech32CreateChecksum(hrp, data));
      let out = hrp + '1';
      for (let i = 0; i < combined.length; i++) out += BECH32_ALPHABET[combined[i]];
      return out;
    }

    function toNpub(hexPubkey) {
      const bytes = hexToBytes(hexPubkey);
      if (!bytes) return null;
      const five = convertBits(Array.from(bytes), 8, 5, true);
      if (!five) return null;
      return bech32Encode('npub', five);
    }

    // ---- Wire UI ----
    function init() {
      document.addEventListener('visibilitychange', () => {
        isPaused = document.hidden;
        if (!isPaused) lastFrameTs = 0;
      });
      const build = new Date().toISOString().slice(0, 19).replace('T', ' ');
      versionEl.textContent = 'v' + APP_VERSION + ' (' + build + ')';

      ACTIVE_WINDOW_SEC = readRangeSec();
      updateActiveCount();
      updateStatusLine();
      renderPosts();

      btnConnect.addEventListener('click', () => {
        ACTIVE_WINDOW_SEC = readRangeSec();
        updateActiveCount();
        const url = relayInput.value.trim();
        if (url) connectRelay(url);
      });

      btnDisconnect.addEventListener('click', () => {
        disconnectRelay();
      });

      rangeSelect.addEventListener('change', () => {
        ACTIVE_WINDOW_SEC = readRangeSec();
        removeExpiredFishes(nowMs());
        updateActiveCount();
        if (ws && ws.readyState === 1) {
          const url = relayInput.value.trim();
          if (url) connectRelay(url);
        }
      });

      window.addEventListener('resize', resize);
      resize();
      log('ready');
      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>
